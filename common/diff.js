/**
 * Copyright google/diff-match-patch
 * 
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
/**
 * Changes made to the source code:
 * - Extract diff functions from google/diff-match-patch
 * - Rename variables to camelCase
 * - Use ES6 syntax such as class, method, const, let, etc.
 * - Remove underscores (_) in names
 */

/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
export const DIFF_DELETE = -1;
export const DIFF_INSERT = 1;
export const DIFF_EQUAL = 0;

// Define some regex patterns for matching boundaries.
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/;
const whitespaceRegex = /\s/;
const linebreakRegex = /[\r\n]/;
const blanklineEndRegex = /\n\r?\n$/;
const blanklineStartRegex = /^\r?\n\r?\n/;

export class Tuple {
  /**
   * Class representing one diff tuple.
   * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
   * @param {string} text Text to be deleted, inserted, or retained.
   */
  constructor(op, text) {
    this.op = op;
    this.text = text;
  }
}

export class Diff {
  // Number of seconds to map a diff before giving up (0 for infinity).
  timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  editCost = 4;

  /**
   * Find the differences between two texts.  Simplifies the problem by stripping
   * any common prefix or suffix off the texts before diffing.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {boolean=} optChecklines Optional speedup flag. If present and false,
   *     then don't run a line-level diff first to identify the changed areas.
   *     Defaults to true, which does a faster, slightly less optimal diff.
   * @param {number=} optDeadline Optional time when the diff should be complete
   *     by.  Used internally for recursive calls.  Users should set DiffTimeout
   *     instead.
   * @return {!Array.<!Tuple>} Array of diff tuples.
   */
  main(text1, text2, optChecklines, optDeadline) {
    // Set a deadline by which time the diff must be complete.
    if (typeof optDeadline === 'undefined') {
      if (this.timeout <= 0) {
        optDeadline = Number.MAX_VALUE;
      } else {
        optDeadline = (new Date).getTime() + this.timeout * 1000;
      }
    }

    // Check for null inputs.
    if (text1 === null || text2 === null) {
      throw new Error('Null input. (main)');
    }

    // Check for equality (speedup).
    if (text1 === text2) {
      if (text1) {
        return [new Tuple(DIFF_EQUAL, text1)];
      }
      return [];
    }

    if (typeof optChecklines === 'undefined') {
      optChecklines = true;
    }

    // Trim off common prefix (speedup).
    let commonlength = this.commonPrefix(text1, text2);
    const commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup).
    commonlength = this.commonSuffix(text1, text2);
    const commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    // Compute the diff on the middle block.
    const diffs = this.compute(text1, text2, optChecklines, optDeadline);

    // Restore the prefix and suffix.
    if (commonprefix) {
      diffs.unshift(new Tuple(DIFF_EQUAL, commonprefix));
    }
    if (commonsuffix) {
      diffs.push(new Tuple(DIFF_EQUAL, commonsuffix));
    }
    this.cleanupMerge(diffs);
    return diffs;
  }

  /**
   * Determine the common prefix of two strings.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the start of each
   *     string.
   */
  commonPrefix(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
      return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    let min = 0;
    let max = Math.min(text1.length, text2.length);
    let mid = max;
    let start = 0;
    while (min < mid) {
      if (text1.substring(start, mid) == text2.substring(start, mid)) {
        min = mid;
        start = min;
      } else {
        max = mid;
      }
      mid = Math.floor((max - min) / 2 + min);
    }
    return mid;
  }

  /**
   * Determine the common suffix of two strings.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the end of each string.
   */
  commonSuffix(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
      return 0;
    }
    // Binary search.
    // Performance analysis: https://neil.fraser.name/news/2007/10/09/
    let min = 0;
    let max = Math.min(text1.length, text2.length);
    let mid = max;
    let end = 0;
    while (min < mid) {
      if (text1.substring(text1.length - mid, text1.length - end) ==
        text2.substring(text2.length - mid, text2.length - end)) {
        min = mid;
        end = min;
      } else {
        max = mid;
      }
      mid = Math.floor((max - min) / 2 + min);
    }
    return mid;
  }

  /**
   * Find the differences between two texts.  Assumes that the texts do not
   * have any common prefix or suffix.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {boolean} checklines Speedup flag.  If false, then don't run a
   *     line-level diff first to identify the changed areas.
   *     If true, then run a faster, slightly less optimal diff.
   * @param {number} deadline Time when the diff should be complete by.
   * @return {!Array.<!Tuple>} Array of diff tuples.
   * @private
   */
  compute(text1, text2, checklines, deadline) {
    let diffs;

    if (!text1) {
      // Just add some text (speedup).
      return [new Tuple(DIFF_INSERT, text2)];
    }

    if (!text2) {
      // Just delete some text (speedup).
      return [new Tuple(DIFF_DELETE, text1)];
    }

    let longText = text1.length > text2.length ? text1 : text2;
    let shortText = text1.length > text2.length ? text2 : text1;
    let i = longText.indexOf(shortText);
    if (i != -1) {
      // Shorter text is inside the longer text (speedup).
      diffs = [
        new Tuple(DIFF_INSERT, longText.substring(0, i)),
        new Tuple(DIFF_EQUAL, shortText),
        new Tuple(DIFF_INSERT, longText.substring(i + shortText.length)),
      ];
      // Swap insertions for deletions if diff is reversed.
      if (text1.length > text2.length) {
        diffs[0].op = diffs[2].op = DIFF_DELETE;
      }
      return diffs;
    }

    if (shortText.length == 1) {
      // Single character string.
      // After the previous speedup, the character can't be an equality.
      return [new Tuple(DIFF_DELETE, text1), new Tuple(DIFF_INSERT, text2)];
    }

    // Check to see if the problem can be split in two.
    let hm = this.halfMatch(text1, text2);
    if (hm) {
      // A half-match was found, sort out the return data.
      const text1A = hm[0];
      const text1B = hm[1];
      const text2A = hm[2];
      const text2B = hm[3];
      const midCommon = hm[4];
      // Send both pairs off for separate processing.
      const diffsA = this.main(text1A, text2A, checklines, deadline);
      const diffsB = this.main(text1B, text2B, checklines, deadline);
      // Merge the results.
      return diffsA.concat([new Tuple(DIFF_EQUAL, midCommon)], diffsB);
    }

    if (checklines && text1.length > 100 && text2.length > 100) {
      return this.lineMode(text1, text2, deadline);
    }

    return this.bisect(text1, text2, deadline);
  }

  /**
   * Do the two texts share a substring which is at least half the length of the
   * longer text?
   * This speedup can produce non-minimal diffs.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     text1, the suffix of text1, the prefix of text2, the suffix of
   *     text2 and the common middle.  Or null if there was no match.
   * @private
   */
  halfMatch(text1, text2) {
    if (this.timeout <= 0) {
      // Don't risk returning a non-optimal diff if we have unlimited time.
      return null;
    }
    const longText = text1.length > text2.length ? text1 : text2;
    const shortText = text1.length > text2.length ? text2 : text1;
    if (longText.length < 4 || shortText.length * 2 < longText.length) {
      return null;  // Pointless.
    }
    const self = this;  // 'this' becomes 'window' in a closure.

    /**
     * Does a substring of shorttext exist within longtext such that the substring
     * is at least half the length of longtext?
     * Closure, but does not reference any external variables.
     * @param {string} longText Longer string.
     * @param {string} shortText Shorter string.
     * @param {number} i Start index of quarter length substring within longtext.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
     *     of shorttext and the common middle.  Or null if there was no match.
     */
    const halfMatchI = (longText, shortText, i) => {
      // Start with a 1/4 length substring at position i as a seed.
      const seed = longText.substring(i, i + Math.floor(longText.length / 4));
      let j = -1;
      let bestCommon = '';
      let bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
      while ((j = shortText.indexOf(seed, j + 1)) != -1) {
        const prefixLength = self.commonPrefix(longText.substring(i), shortText.substring(j));
        const suffixLength = self.commonSuffix(longText.substring(0, i), shortText.substring(0, j));
        if (bestCommon.length < suffixLength + prefixLength) {
          bestCommon = shortText.substring(j - suffixLength, j) + shortText.substring(j, j + prefixLength);
          bestLongTextA = longText.substring(0, i - suffixLength);
          bestLongTextB = longText.substring(i + prefixLength);
          bestShortTextA = shortText.substring(0, j - suffixLength);
          bestShortTextB = shortText.substring(j + prefixLength);
        }
      }
      if (bestCommon.length * 2 >= longText.length) {
        return [bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB, bestCommon];
      } else {
        return null;
      }
    }

    // First check if the second quarter is the seed for a half-match.
    const hm1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4));
    // Check again based on the third quarter.
    const hm2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
    let hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      // Both matched.  Select the longest.
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    // A half-match was found, sort out the return data.
    let text1A, text1B, text2A, text2B;
    if (text1.length > text2.length) {
      text1A = hm[0];
      text1B = hm[1];
      text2A = hm[2];
      text2B = hm[3];
    } else {
      text2A = hm[0];
      text2B = hm[1];
      text1A = hm[2];
      text1B = hm[3];
    }
    const midCommon = hm[4];
    return [text1A, text1B, text2A, text2B, midCommon];
  }

  /**
   * Do a quick line-level diff on both strings, then rediff the parts for
   * greater accuracy.
   * This speedup can produce non-minimal diffs.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} deadline Time when the diff should be complete by.
   * @return {!Array.<!Tuple>} Array of diff tuples.
   * @private
   */
  lineMode(text1, text2, deadline) {
    // Scan the text on a line-by-line basis first.
    const a = this.linesToChars(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    const lineArray = a.lineArray;

    const diffs = this.main(text1, text2, false, deadline);

    // Convert the diff back to original text.
    this.charsToLines(diffs, lineArray);
    // Eliminate freak matches (e.g. blank lines)
    this.cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push(new Tuple(DIFF_EQUAL, ''));
    let pointer = 0;
    let countDelete = 0;
    let countInsert = 0;
    let textDelete = '';
    let textInsert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer].op) {
        case DIFF_INSERT:
          countInsert++;
          textInsert += diffs[pointer].text;
          break;
        case DIFF_DELETE:
          countDelete++;
          textDelete += diffs[pointer].text;
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (countDelete >= 1 && countInsert >= 1) {
            // Delete the offending records and add the merged ones.
            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
            pointer = pointer - countDelete - countInsert;
            const subDiff = this.main(textDelete, textInsert, false, deadline);
            for (let j = subDiff.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, subDiff[j]);
            }
            pointer = pointer + subDiff.length;
          }
          countInsert = 0;
          countDelete = 0;
          textDelete = '';
          textInsert = '';
          break;
      }
      pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.

    return diffs;
  }

  /**
   * Split two texts into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
   *     An object containing the encoded text1, the encoded text2 and
   *     the array of unique strings.
   *     The zeroth element of the array of unique strings is intentionally blank.
   * @private
   */
  linesToChars(text1, text2) {
    let lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
    let lineHash = {};   // e.g. lineHash['Hello\n'] == 4

    // '\x00' is a valid character, but various debuggers don't like it.
    // So we'll insert a junk entry to avoid generating a null character.
    lineArray[0] = '';

    /**
     * Split a text into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * Modifies linearray and linehash through being a closure.
     * @param {string} text String to encode.
     * @return {string} Encoded string.
     * @private
     */
    function linesToCharsMunge(text) {
      let chars = '';
      // Walk the text, pulling out a substring for each line.
      // text.split('\n') would would temporarily double our memory footprint.
      // Modifying text would create many large strings to garbage collect.
      let lineStart = 0;
      let lineEnd = -1;
      // Keeping our own length variable is faster than looking it up.
      let lineArrayLength = lineArray.length;
      while (lineEnd < text.length - 1) {
        lineEnd = text.indexOf('\n', lineStart);
        if (lineEnd == -1) {
          lineEnd = text.length - 1;
        }
        let line = text.substring(lineStart, lineEnd + 1);

        if (Object.prototype.hasOwnProperty.call(lineHash, line)) {
          chars += String.fromCharCode(lineHash[line]);
        } else {
          if (lineArrayLength == maxLines) {
            // Bail out at 65535 because
            // String.fromCharCode(65536) == String.fromCharCode(0)
            line = text.substring(lineStart);
            lineEnd = text.length;
          }
          chars += String.fromCharCode(lineArrayLength);
          lineHash[line] = lineArrayLength;
          lineArray[lineArrayLength++] = line;
        }
        lineStart = lineEnd + 1;
      }
      return chars;
    }
    // Allocate 2/3rds of the space for text1, the rest for text2.
    let maxLines = 40000;
    const chars1 = linesToCharsMunge(text1);
    maxLines = 65535;
    const chars2 = linesToCharsMunge(text2);
    return { chars1, chars2, lineArray };
  }

  /**
   * Rehydrate the text in a diff from a string of line hashes to real lines of
   * text.
   * @param {!Array.<!Tuple>} diffs Array of diff tuples.
   * @param {!Array.<string>} lineArray Array of unique strings.
   * @private
   */
  charsToLines(diffs, lineArray) {
    for (let i = 0; i < diffs.length; i++) {
      let chars = diffs[i].text;
      let text = [];
      for (let j = 0; j < chars.length; j++) {
        text[j] = lineArray[chars.charCodeAt(j)];
      }
      diffs[i].text = text.join('');
    }
  }

  /**
   * Reduce the number of edits by eliminating semantically trivial equalities.
   * @param {!Array.<!Tuple>} diffs Array of diff tuples.
   */
  cleanupSemantic(diffs) {
    let changes = false;
    let equalities = [];  // Stack of indices where equalities are found.
    let equalitiesLength = 0;  // Keeping our own length var is faster in JS.
    /** @type {?string} */
    let lastEquality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]].text
    let pointer = 0;  // Index of current position.
    // Number of characters that changed prior to the equality.
    let lengthInsertions1 = 0;
    let lengthDeletions1 = 0;
    // Number of characters that changed after the equality.
    let lengthInsertions2 = 0;
    let lengthDeletions2 = 0;
    while (pointer < diffs.length) {
      if (diffs[pointer].op == DIFF_EQUAL) {  // Equality found.
        equalities[equalitiesLength++] = pointer;
        lengthInsertions1 = lengthInsertions2;
        lengthDeletions1 = lengthDeletions2;
        lengthInsertions2 = 0;
        lengthDeletions2 = 0;
        lastEquality = diffs[pointer].text;
      } else {  // An insertion or deletion.
        if (diffs[pointer].op == DIFF_INSERT) {
          lengthInsertions2 += diffs[pointer].text.length;
        } else {
          lengthDeletions2 += diffs[pointer].text.length;
        }
        // Eliminate an equality that is smaller or equal to the edits on both
        // sides of it.
        if (lastEquality && (lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1)) &&
          (lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2))) {
          // Duplicate record.
          diffs.splice(equalities[equalitiesLength - 1], 0, new Tuple(DIFF_DELETE, lastEquality));
          // Change second copy to insert.
          diffs[equalities[equalitiesLength - 1] + 1].op = DIFF_INSERT;
          // Throw away the equality we just deleted.
          equalitiesLength--;
          // Throw away the previous equality (it needs to be reevaluated).
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          lengthInsertions1 = 0;  // Reset the counters.
          lengthDeletions1 = 0;
          lengthInsertions2 = 0;
          lengthDeletions2 = 0;
          lastEquality = null;
          changes = true;
        }
      }
      pointer++;
    }

    // Normalize the diff.
    if (changes) {
      this.cleanupMerge(diffs);
    }
    this.cleanupSemanticLossless(diffs);

    // Find any overlaps between deletions and insertions.
    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
    //   -> <del>abc</del>xxx<ins>def</ins>
    // e.g: <del>xxxabc</del><ins>defxxx</ins>
    //   -> <ins>def</ins>xxx<del>abc</del>
    // Only extract an overlap if it is as big as the edit ahead or behind it.
    pointer = 1;
    while (pointer < diffs.length) {
      if (diffs[pointer - 1].op == DIFF_DELETE && diffs[pointer].op == DIFF_INSERT) {
        let deletion = diffs[pointer - 1].text;
        let insertion = diffs[pointer].text;
        let overlapLength1 = this.commonOverlap(deletion, insertion);
        let overlapLength2 = this.commonOverlap(insertion, deletion);
        if (overlapLength1 >= overlapLength2) {
          if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
            // Overlap found.  Insert an equality and trim the surrounding edits.
            diffs.splice(pointer, 0, new Tuple(DIFF_EQUAL, insertion.substring(0, overlapLength1)));
            diffs[pointer - 1].text = deletion.substring(0, deletion.length - overlapLength1);
            diffs[pointer + 1].text = insertion.substring(overlapLength1);
            pointer++;
          }
        } else {
          if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
            // Reverse overlap found.
            // Insert an equality and swap and trim the surrounding edits.
            diffs.splice(pointer, 0, new Tuple(DIFF_EQUAL, deletion.substring(0, overlapLength2)));
            diffs[pointer - 1].op = DIFF_INSERT;
            diffs[pointer - 1].text = insertion.substring(0, insertion.length - overlapLength2);
            diffs[pointer + 1].op = DIFF_DELETE;
            diffs[pointer + 1].text = deletion.substring(overlapLength2);
            pointer++;
          }
        }
        pointer++;
      }
      pointer++;
    }
  }

  /**
   * Reorder and merge like edit sections.  Merge equalities.
   * Any edit section can move as long as it doesn't cross an equality.
   * @param {!Array.<!Tuple>} diffs Array of diff tuples.
   */
  cleanupMerge(diffs) {
    // Add a dummy entry at the end.
    diffs.push(new Tuple(DIFF_EQUAL, ''));
    let pointer = 0;
    let countDelete = 0;
    let countInsert = 0;
    let textDelete = '';
    let textInsert = '';
    let commonlength;
    while (pointer < diffs.length) {
      switch (diffs[pointer].op) {
        case DIFF_INSERT:
          countInsert++;
          textInsert += diffs[pointer].text;
          pointer++;
          break;
        case DIFF_DELETE:
          countDelete++;
          textDelete += diffs[pointer].text;
          pointer++;
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (countDelete + countInsert > 1) {
            if (countDelete !== 0 && countInsert !== 0) {
              // Factor out any common prefixies.
              commonlength = this.commonPrefix(textInsert, textDelete);
              if (commonlength !== 0) {
                if ((pointer - countDelete - countInsert) > 0 &&
                  diffs[pointer - countDelete - countInsert - 1].op == DIFF_EQUAL) {
                  diffs[pointer - countDelete - countInsert - 1].text +=
                    textInsert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, new Tuple(DIFF_EQUAL, textInsert.substring(0, commonlength)));
                  pointer++;
                }
                textInsert = textInsert.substring(commonlength);
                textDelete = textDelete.substring(commonlength);
              }
              // Factor out any common suffixies.
              commonlength = this.commonSuffix(textInsert, textDelete);
              if (commonlength !== 0) {
                diffs[pointer].text = textInsert.substring(textInsert.length - commonlength) +
                  diffs[pointer].text;
                textInsert = textInsert.substring(0, textInsert.length - commonlength);
                textDelete = textDelete.substring(0, textDelete.length - commonlength);
              }
            }
            // Delete the offending records and add the merged ones.
            pointer -= countDelete + countInsert;
            diffs.splice(pointer, countDelete + countInsert);
            if (textDelete.length) {
              diffs.splice(pointer, 0, new Tuple(DIFF_DELETE, textDelete));
              pointer++;
            }
            if (textInsert.length) {
              diffs.splice(pointer, 0, new Tuple(DIFF_INSERT, textInsert));
              pointer++;
            }
            pointer++;
          } else if (pointer !== 0 && diffs[pointer - 1].op == DIFF_EQUAL) {
            // Merge this equality with the previous one.
            diffs[pointer - 1].text += diffs[pointer].text;
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          countInsert = 0;
          countDelete = 0;
          textDelete = '';
          textInsert = '';
          break;
      }
    }
    if (diffs[diffs.length - 1].text === '') {
      diffs.pop();  // Remove the dummy entry at the end.
    }

    // Second pass: look for single edits surrounded on both sides by equalities
    // which can be shifted sideways to eliminate an equality.
    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    let changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1].op == DIFF_EQUAL && diffs[pointer + 1].op == DIFF_EQUAL) {
        // This is a single edit surrounded by equalities.
        if (diffs[pointer].text.substring(diffs[pointer].text.length -
          diffs[pointer - 1].text.length) == diffs[pointer - 1].text) {
          // Shift the edit over the previous equality.
          diffs[pointer].text = diffs[pointer - 1].text +
            diffs[pointer].text.substring(0, diffs[pointer].text.length -
              diffs[pointer - 1].text.length);
          diffs[pointer + 1].text = diffs[pointer - 1].text + diffs[pointer + 1].text;
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer].text.substring(0, diffs[pointer + 1].text.length) ==
          diffs[pointer + 1].text) {
          // Shift the edit over the next equality.
          diffs[pointer - 1].text += diffs[pointer + 1].text;
          diffs[pointer].text =
            diffs[pointer].text.substring(diffs[pointer + 1].text.length) +
            diffs[pointer + 1].text;
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
      this.cleanupMerge(diffs);
    }
  }

  /**
   * Look for single edits surrounded on both sides by equalities
   * which can be shifted sideways to align the edit to a word boundary.
   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
   * @param {!Array.<!Tuple>} diffs Array of diff tuples.
   */
  cleanupSemanticLossless(diffs) {
    /**
     * Given two strings, compute a score representing whether the internal
     * boundary falls on logical boundaries.
     * Scores range from 6 (best) to 0 (worst).
     * Closure, but does not reference any external variables.
     * @param {string} one First string.
     * @param {string} two Second string.
     * @return {number} The score.
     * @private
     */
    function cleanupSemanticScore(one, two) {
      if (!one || !two) {
        // Edges are the best.
        return 6;
      }

      // Each port of this function behaves slightly differently due to
      // subtle differences in each language's definition of things like
      // 'whitespace'.  Since this function's purpose is largely cosmetic,
      // the choice has been made to use each language's native features
      // rather than force total conformity.
      const char1 = one.charAt(one.length - 1);
      const char2 = two.charAt(0);
      const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex);
      const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex);
      const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex);
      const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex);
      const lineBreak1 = whitespace1 && char1.match(linebreakRegex);
      const lineBreak2 = whitespace2 && char2.match(linebreakRegex);
      const blankLine1 = lineBreak1 && one.match(blanklineEndRegex);
      const blankLine2 = lineBreak2 && two.match(blanklineStartRegex);

      if (blankLine1 || blankLine2) {
        // Five points for blank lines.
        return 5;
      } else if (lineBreak1 || lineBreak2) {
        // Four points for line breaks.
        return 4;
      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
        // Three points for end of sentences.
        return 3;
      } else if (whitespace1 || whitespace2) {
        // Two points for whitespace.
        return 2;
      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
        // One point for non-alphanumeric.
        return 1;
      }
      return 0;
    }

    let pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1].op == DIFF_EQUAL && diffs[pointer + 1].op == DIFF_EQUAL) {
        // This is a single edit surrounded by equalities.
        let equality1 = diffs[pointer - 1].text;
        let edit = diffs[pointer].text;
        let equality2 = diffs[pointer + 1].text;

        // First, shift the edit as far left as possible.
        const commonOffset = this.commonSuffix(equality1, edit);
        if (commonOffset) {
          const commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset);
          edit = commonString + edit.substring(0, edit.length - commonOffset);
          equality2 = commonString + equality2;
        }

        // Second, step character by character right, looking for the best fit.
        let bestEquality1 = equality1;
        let bestEdit = edit;
        let bestEquality2 = equality2;
        let bestScore = cleanupSemanticScore(equality1, edit) + cleanupSemanticScore(edit, equality2);
        while (edit.charAt(0) === equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          const score = cleanupSemanticScore(equality1, edit) + cleanupSemanticScore(edit, equality2);
          // The >= encourages trailing rather than leading whitespace on edits.
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }

        if (diffs[pointer - 1].text != bestEquality1) {
          // We have an improvement, save it back to the diff.
          if (bestEquality1) {
            diffs[pointer - 1].text = bestEquality1;
          } else {
            diffs.splice(pointer - 1, 1);
            pointer--;
          }
          diffs[pointer].text = bestEdit;
          if (bestEquality2) {
            diffs[pointer + 1].text = bestEquality2;
          } else {
            diffs.splice(pointer + 1, 1);
            pointer--;
          }
        }
      }
      pointer++;
    }
  }

  /**
   * Determine if the suffix of one string is the prefix of another.
   * @param {string} text1 First string.
   * @param {string} text2 Second string.
   * @return {number} The number of characters common to the end of the first
   *     string and the start of the second string.
   * @private
   */
  commonOverlap(text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    const text1Length = text1.length;
    const text2Length = text2.length;
    // Eliminate the null case.
    if (text1Length == 0 || text2Length == 0) {
      return 0;
    }
    // Truncate the longer string.
    if (text1Length > text2Length) {
      text1 = text1.substring(text1Length - text2Length);
    } else if (text1Length < text2Length) {
      text2 = text2.substring(0, text1Length);
    }
    const textLength = Math.min(text1Length, text2Length);
    // Quick check for the worst case.
    if (text1 == text2) {
      return textLength;
    }

    // Start by looking for a single character match
    // and increase length until no match is found.
    // Performance analysis: https://neil.fraser.name/news/2010/11/04/
    let best = 0;
    let length = 1;
    for (; ;) {
      const pattern = text1.substring(textLength - length);
      const found = text2.indexOf(pattern);
      if (found == -1) {
        return best;
      }
      length += found;
      if (found == 0 || text1.substring(textLength - length) == text2.substring(0, length)) {
        best = length;
        length++;
      }
    }
  }

  /**
   * Find the 'middle snake' of a diff, split the problem in two
   * and return the recursively constructed diff.
   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} deadline Time at which to bail if not yet complete.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  bisect(text1, text2, deadline) {
    // Cache the text lengths to prevent multiple calls.
    let text1_length = text1.length;
    let text2_length = text2.length;
    let max_d = Math.ceil((text1_length + text2_length) / 2);
    let v_offset = max_d;
    let v_length = 2 * max_d;
    let v1 = new Array(v_length);
    let v2 = new Array(v_length);
    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
    // integers and undefined.
    for (let x = 0; x < v_length; x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    let delta = text1_length - text2_length;
    // If the total number of characters is odd, then the front path will collide
    // with the reverse path.
    let front = (delta % 2 != 0);
    // Offsets for start and end of k loop.
    // Prevents mapping of space beyond the grid.
    let k1start = 0;
    let k1end = 0;
    let k2start = 0;
    let k2end = 0;
    for (let d = 0; d < max_d; d++) {
      // Bail out if deadline is reached.
      if ((new Date()).getTime() > deadline) {
        break;
      }

      // Walk the front path one step.
      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        let k1_offset = v_offset + k1;
        let x1;
        if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        let y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          // Ran off the right of the graph.
          k1end += 2;
        } else if (y1 > text2_length) {
          // Ran off the bottom of the graph.
          k1start += 2;
        } else if (front) {
          let k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
            // Mirror x2 onto top-left coordinate system.
            let x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              // Overlap detected.
              return this.bisectSplit(text1, text2, x1, y1, deadline);
            }
          }
        }
      }

      // Walk the reverse path one step.
      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        let k2_offset = v_offset + k2;
        let x2;
        if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        let y2 = x2 - k2;
        while (x2 < text1_length && y2 < text2_length &&
          text1.charAt(text1_length - x2 - 1) ==
          text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          // Ran off the left of the graph.
          k2end += 2;
        } else if (y2 > text2_length) {
          // Ran off the top of the graph.
          k2start += 2;
        } else if (!front) {
          let k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
            let x1 = v1[k1_offset];
            let y1 = v_offset + x1 - k1_offset;
            // Mirror x2 onto top-left coordinate system.
            x2 = text1_length - x2;
            if (x1 >= x2) {
              // Overlap detected.
              return this.bisectSplit(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
    }
    // Diff took too long and hit the deadline or
    // number of diffs equals number of characters, no commonality at all.
    return [new Tuple(DIFF_DELETE, text1), new Tuple(DIFF_INSERT, text2)];
  }

  /**
   * Given the location of the 'middle snake', split the diff in two parts
   * and recurse.
   * @param {string} text1 Old string to be diffed.
   * @param {string} text2 New string to be diffed.
   * @param {number} x Index of split point in text1.
   * @param {number} y Index of split point in text2.
   * @param {number} deadline Time at which to bail if not yet complete.
   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
   * @private
   */
  bisectSplit(text1, text2, x, y, deadline) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);

    // Compute both diffs serially.
    var diffs = this.main(text1a, text2a, false, deadline);
    var diffsb = this.main(text1b, text2b, false, deadline);

    return diffs.concat(diffsb);
  }
}
